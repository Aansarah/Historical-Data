# -*- coding: utf-8 -*-
"""Historical_prices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uRl6N_PNIkAb2cEYoXKQzA96gyY16m_k
"""

from google.colab import drive
drive.mount('/content/drive')

#Importing Libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the data
data = pd.read_csv("/content/drive/MyDrive/final project/historical_prices_.csv")


# Data Preprocessing
# Convert 'Date' to datetime format
data['Date'] = pd.to_datetime(data['Date'])
# Sort data by date
data.sort_values('Date', inplace=True)
# Set 'Date' as index
data.set_index('Date', inplace=True)

# Handle missing values
# Assuming 'Close' is the main column of interest, fill missing values with the previous value
data['Close'].fillna(method='ffill', inplace=True)

# Calculate daily percentage change
data['Daily Change %'] = data['Close'].pct_change() * 100

data.head()

### Step 2: Analytical Techniques
#Now that the data is preprocessed, I will proceed with the analytical techniques:

#1. **Trend Analysis**: Calculate moving averages (20-day and 50-day) to identify trends.
#2. **Volatility Analysis**: Calculate Bollinger Bands and the Relative Strength Index (RSI) to assess volatility.

#Let's calculate the moving averages first.

# Calculate moving averages
data['MA20'] = data['Close'].rolling(window=20).mean()
data['MA50'] = data['Close'].rolling(window=50).mean()

data[['Close', 'MA20', 'MA50']].head(25)

### Step 3: Volatility Analysis

#Next, I will calculate the Bollinger Bands and the Relative Strength Index (RSI) to assess volatility.

#Let's start with calculating the Bollinger Bands.

# Calculate Bollinger Bands
window = 20
std_dev = 2
data['BB_upper'] = data['MA20'] + (data['Close'].rolling(window=window).std() * std_dev)
data['BB_lower'] = data['MA20'] - (data['Close'].rolling(window=window).std() * std_dev)

data[['Close', 'BB_upper', 'BB_lower']].head(25)

#Now, let's calculate the Relative Strength Index (RSI) to further assess volatility.

def calculate_rsi(data, window=14):
    delta = data['Close'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Calculate RSI
data['RSI'] = calculate_rsi(data)

data[['Close', 'RSI']].head(25)

from statsmodels.tsa.stattools import adfuller

# Augmented Dickey-Fuller Test
adf_test = adfuller(data['Close'].dropna())

print("ADF Test Statistic:", adf_test[0])
print("p-value:", adf_test[1])
print("Critical Values:", adf_test[4])

if adf_test[1] <= 0.05:
    print("The time series is stationary (reject null hypothesis).")
else:
    print("The time series is not stationary (fail to reject null hypothesis).")

from scipy.stats import shapiro

# Shapiro-Wilk Test
stat, p = shapiro(data['Daily Change %'].dropna())

print("Shapiro-Wilk Test Statistic:", stat)
print("p-value:", p)

from scipy.stats import ttest_ind

# Define a split date
split_date = '2023-01-01'

# Divide the data
pre_split = data[data.index < split_date]['Daily Change %'].dropna()
post_split = data[data.index >= split_date]['Daily Change %'].dropna()

# T-Test
t_stat, p_value = ttest_ind(pre_split, post_split)

print("T-Test Statistic:", t_stat)
print("p-value:", p_value)

if p_value <= 0.05:
    print("There is a significant difference in volatility before and after the split date.")
else:
    print("There is no significant difference in volatility before and after the split date.")



